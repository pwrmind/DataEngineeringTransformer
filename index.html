<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Engineering Transformer</title>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f8f9fa;
        }
        .pipeline-visualization {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .transformation-block {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-left: 4px solid #007bff;
        }
        .data-table-container {
            max-height: 300px;
            overflow-y: auto;
            font-size: 0.875rem;
        }
        .step-number {
            background: #007bff;
            color: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 10px;
        }
        .node {
            cursor: pointer;
        }
        .node:hover {
            opacity: 0.8;
        }
        .alert-custom {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 400px;
        }
    </style>
</head>
<body>
    <div id="app" x-data="app()" x-init="init()">
        <!-- Уведомления -->
        <div id="notificationContainer" class="alert-custom"></div>

        <!-- Визуализация пайплайна -->
        <div class="container-sm mt-3">
            <div class="pipeline-visualization">
                <h5 class="mb-3"><i class="fas fa-project-diagram me-2"></i>Pipeline Visualization</h5>
                <div id="pipelineChart"></div>
            </div>
        </div>

        <!-- Основной контент -->
        <div class="container-sm">
            <!-- Компонент загрузки данных -->
            <div class="row">
                <div class="col-12">
                    <div class="card mb-4">
                        <div class="card-header">
                            <h5 class="mb-0"><i class="fas fa-database me-2"></i>Data Loader</h5>
                        </div>
                        <div class="card-body">
                            <div class="row g-2 mb-3">
                                <div class="col-md-6">
                                    <label class="form-label small">Upload JSON File</label>
                                    <input type="file" class="form-control form-control-sm" @change="handleFileUpload($event)" accept=".json">
                                </div>
                                <div class="col-md-6">
                                    <label class="form-label small">Or paste JSON</label>
                                    <textarea 
                                        x-model="jsonInput" 
                                        class="form-control form-control-sm" 
                                        rows="3" 
                                        placeholder='[{"id": 1, "name": "John"}]'
                                    ></textarea>
                                </div>
                            </div>
                            <div class="row g-2">
                                <div class="col-md-6">
                                    <button 
                                        @click="loadCustomData(jsonInput)" 
                                        class="btn btn-sm btn-primary w-100"
                                        :disabled="!jsonInput.trim()"
                                    >
                                        <i class="fas fa-upload me-1"></i>Load from Text
                                    </button>
                                </div>
                                <div class="col-md-6">
                                    <button 
                                        @click="resetToSample()" 
                                        class="btn btn-sm btn-outline-secondary w-100"
                                    >
                                        <i class="fas fa-redo me-1"></i>Reset to Sample
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Таблица данных -->
                    <div class="card">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">
                                <i class="fas fa-table me-2"></i>Data Preview 
                                <small class="text-muted">(Showing <span x-text="currentData.length"></span> items)</small>
                            </h5>
                            <div>
                                <button class="btn btn-sm btn-outline-primary me-1" @click="copyToClipboard()">
                                    <i class="fas fa-copy me-1"></i>Copy
                                </button>
                                <button class="btn btn-sm btn-outline-success" @click="exportData()">
                                    <i class="fas fa-download me-1"></i>Export
                                </button>
                            </div>
                        </div>
                        <div class="card-body p-0">
                            <div class="data-table-container">
                                <table class="table table-sm table-striped mb-0">
                                    <thead class="table-light sticky-top">
                                        <tr>
                                            <template x-for="(value, key) in currentData[0] || {}" :key="key">
                                                <th x-text="key"></th>
                                            </template>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <template x-for="(item, index) in currentData.slice(0, 100)" :key="index">
                                            <tr>
                                                <template x-for="(value, key) in item" :key="key">
                                                    <td>
                                                        <span x-text="typeof value === 'object' ? JSON.stringify(value) : value"></span>
                                                    </td>
                                                </template>
                                            </tr>
                                        </template>
                                    </tbody>
                                </table>
                                <div x-show="currentData.length > 100" class="p-2 text-center text-muted">
                                    <small>Showing first 100 of <span x-text="currentData.length"></span> items</small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Система шагов трансформации -->
            <div class="row mt-4">
                <div class="col-12">
                    <h5><i class="fas fa-cogs me-2"></i>Transformation Pipeline</h5>

                    <!-- Контейнер для шагов трансформации -->
                    <div id="transformationSteps">
                        <template x-for="(step, index) in pipelineSteps" :key="step.id">
                            <div class="transformation-block">
                                <div class="d-flex align-items-center mb-3">
                                    <div class="step-number" x-text="index + 1"></div>
                                    <div class="flex-grow-1">
                                        <h6 class="mb-1" x-text="'Step ' + (index + 1) + ': ' + step.method"></h6>
                                        <small class="text-muted" x-text="'Input: ' + (getStepInput(index).length || 0) + ' items'"></small>
                                    </div>
                                    <div>
                                        <button class="btn btn-sm btn-outline-danger" @click="removeStep(index)">
                                            <i class="fas fa-trash"></i>
                                        </button>
                                    </div>
                                </div>

                                <!-- Панель выбора метода -->
                                <div class="row g-2 mb-3">
                                    <div class="col-sm-6">
                                        <label class="form-label small">Transformation Method</label>
                                        <select 
                                            class="form-select form-select-sm" 
                                            x-model="step.method"
                                            @change="onMethodChange(index)"
                                        >
                                            <option value="map">Map</option>
                                            <option value="filter">Filter</option>
                                            <option value="reduce">Reduce</option>
                                            <option value="flatMap">FlatMap</option>
                                            <option value="slice">Slice</option>
                                            <option value="concat">Concat</option>
                                            <option value="join">Join</option>
                                        </select>
                                    </div>
                                    <div class="col-sm-6">
                                        <label class="form-label small">Step Name</label>
                                        <input type="text" class="form-control form-control-sm" x-model="step.name" :placeholder="'Step ' + (index + 1)">
                                    </div>
                                </div>

                                <!-- Динамическая панель параметров -->
                                <div>
                                    <!-- Map -->
                                    <template x-if="step.method === 'map'">
                                        <div class="row g-2">
                                            <div class="col-sm-6">
                                                <label class="form-label small">Source Field (optional)</label>
                                                <input type="text" class="form-control form-control-sm" 
                                                       x-model="step.parameters.sourceField" 
                                                       placeholder="fieldName">
                                            </div>
                                            <div class="col-sm-6">
                                                <label class="form-label small">Expression</label>
                                                <input type="text" class="form-control form-control-sm" 
                                                       x-model="step.parameters.expression" 
                                                       placeholder="item * 2">
                                            </div>
                                            <div class="col-12">
                                                <small class="text-muted">
                                                    Use <code>item</code> to reference current element. Example: <code>item.age * 2</code>
                                                </small>
                                            </div>
                                        </div>
                                    </template>

                                    <!-- Filter -->
                                    <template x-if="step.method === 'filter'">
                                        <div class="row g-2">
                                            <div class="col-12">
                                                <label class="form-label small">Condition</label>
                                                <input type="text" class="form-control form-control-sm" 
                                                       x-model="step.parameters.condition" 
                                                       placeholder="item.age > 25">
                                                <small class="text-muted">
                                                    Use <code>item</code> to reference current element. Example: <code>item.active && item.age > 30</code>
                                                </small>
                                            </div>
                                        </div>
                                    </template>

                                    <!-- Reduce -->
                                    <template x-if="step.method === 'reduce'">
                                        <div class="row g-2">
                                            <div class="col-sm-6">
                                                <label class="form-label small">Initial Value</label>
                                                <input type="text" class="form-control form-control-sm" 
                                                       x-model="step.parameters.initialValue" 
                                                       placeholder='0, "[]", "{}"'>
                                            </div>
                                            <div class="col-sm-6">
                                                <label class="form-label small">Reducer Function</label>
                                                <input type="text" class="form-control form-control-sm" 
                                                       x-model="step.parameters.reducerFunction" 
                                                       placeholder="acc + item.age">
                                            </div>
                                            <div class="col-12">
                                                <small class="text-muted">
                                                    Use <code>acc</code> for accumulator and <code>item</code> for current element. Example: <code>acc + item.value</code>
                                                </small>
                                            </div>
                                        </div>
                                    </template>

                                    <!-- FlatMap -->
                                    <template x-if="step.method === 'flatMap'">
                                        <div class="row g-2">
                                            <div class="col-12">
                                                <label class="form-label small">Expression</label>
                                                <input type="text" class="form-control form-control-sm" 
                                                       x-model="step.parameters.expression" 
                                                       placeholder="item.phones">
                                                <small class="text-muted">
                                                    Should return an array. Example: <code>item.phoneNumbers</code>
                                                </small>
                                            </div>
                                        </div>
                                    </template>

                                    <!-- Slice -->
                                    <template x-if="step.method === 'slice'">
                                        <div class="row g-2">
                                            <div class="col-sm-6">
                                                <label class="form-label small">Start Index</label>
                                                <input type="number" class="form-control form-control-sm" 
                                                       x-model="step.parameters.start" 
                                                       placeholder="0" min="0">
                                            </div>
                                            <div class="col-sm-6">
                                                <label class="form-label small">End Index (optional)</label>
                                                <input type="number" class="form-control form-control-sm" 
                                                       x-model="step.parameters.end" 
                                                       placeholder="10" min="0">
                                            </div>
                                        </div>
                                    </template>

                                    <!-- Concat -->
                                    <template x-if="step.method === 'concat'">
                                        <div class="row g-2">
                                            <div class="col-12">
                                                <label class="form-label small">Array to Concatenate</label>
                                                <textarea class="form-control form-control-sm" 
                                                          x-model="step.parameters.arrayToConcat" 
                                                          rows="2" 
                                                          placeholder='[{"id": 6, "name": "Frank"}]'></textarea>
                                                <small class="text-muted">
                                                    Enter valid JSON array
                                                </small>
                                            </div>
                                        </div>
                                    </template>

                                    <!-- Join -->
                                    <template x-if="step.method === 'join'">
                                        <div class="row g-2">
                                            <div class="col-sm-6">
                                                <label class="form-label small">Separator</label>
                                                <input type="text" class="form-control form-control-sm" 
                                                       x-model="step.parameters.separator" 
                                                       placeholder=",">
                                            </div>
                                            <div class="col-sm-6">
                                                <label class="form-label small">Source Field (optional)</label>
                                                <input type="text" class="form-control form-control-sm" 
                                                       x-model="step.parameters.sourceField" 
                                                       placeholder="name">
                                            </div>
                                        </div>
                                    </template>
                                </div>

                                <!-- Отображение ошибки -->
                                <div x-show="step.error" class="alert alert-danger alert-dismissible fade show mt-2 p-2" role="alert">
                                    <small><strong>Error:</strong> <span x-text="step.error"></span></small>
                                    <button type="button" class="btn-close" style="font-size: 0.5rem;" @click="step.error = null"></button>
                                </div>

                                <!-- Кнопка применения и результат -->
                                <div class="row align-items-center mt-3">
                                    <div class="col">
                                        <button 
                                            class="btn btn-sm btn-primary" 
                                            @click="executeStep(index)"
                                            :disabled="!isStepExecutable(index)"
                                        >
                                            <i class="fas fa-play me-1"></i>Apply Transformation
                                        </button>
                                    </div>
                                    <div class="col-auto">
                                        <small class="text-muted" 
                                               x-text="step.result ? 'Output: ' + (Array.isArray(step.result) ? step.result.length + ' items' : typeof step.result === 'string' ? (step.result.length > 50 ? step.result.substring(0, 50) + '...' : step.result) : step.result) : ''">
                                        </small>
                                    </div>
                                </div>

                                <!-- Мини-таблица с результатом -->
                                <div x-show="step.result && Array.isArray(step.result) && step.result.length > 0" class="mt-3">
                                    <div class="data-table-container">
                                        <table class="table table-sm table-striped mb-0">
                                            <thead class="table-light">
                                                <tr>
                                                    <template x-for="(value, key) in step.result[0]" :key="key">
                                                        <th x-text="key"></th>
                                                    </template>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <template x-for="(item, itemIndex) in step.result.slice(0, 5)" :key="itemIndex">
                                                    <tr>
                                                        <template x-for="(value, key) in item" :key="key">
                                                            <td x-text="typeof value === 'object' ? JSON.stringify(value) : value"></td>
                                                        </template>
                                                    </tr>
                                                </template>
                                            </tbody>
                                        </table>
                                    </div>
                                    <small class="text-muted" x-show="step.result.length > 5">
                                        Showing first 5 of <span x-text="step.result.length"></span> items
                                    </small>
                                </div>
                            </div>
                        </template>
                        
                        <!-- Кнопка добавления шага ПОД всеми шагами -->
                        <div class="text-center mt-3">
                            <button class="btn btn-sm btn-success" @click="addStep()" :disabled="pipelineSteps.length >= 20">
                                <i class="fas fa-plus me-1"></i>Add Transformation Step
                                <span x-show="pipelineSteps.length >= 20" class="ms-1">(Max 20)</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Alpine.js -->
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    
    <!-- D3.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
    
    <script>
        function app() {
            return {
                // Исходные данные
                originalData: [],
                
                // Шаги трансформации
                pipelineSteps: [],
                
                // Следующий ID для шага
                nextStepId: 1,
                
                // JSON input
                jsonInput: '',
                
                // История для undo/redo
                history: [],
                historyIndex: -1,
                isSaved: false,

                // Текущие данные для отображения (последний шаг)
                get currentData() {
                    if (this.pipelineSteps.length === 0) {
                        return this.originalData;
                    }
                    const lastStep = this.pipelineSteps[this.pipelineSteps.length - 1];
                    return lastStep.result || this.originalData;
                },

                // Инициализация тестовыми данными
                init() {
                    // Тестовые данные
                    this.originalData = [
                        { id: 1, name: "Alice", age: 30, city: "London", active: true },
                        { id: 2, name: "Bob", age: 25, city: "New York", active: false },
                        { id: 3, name: "Charlie", age: 35, city: "London", active: true },
                        { id: 4, name: "Diana", age: 28, city: "Paris", active: true },
                        { id: 5, name: "Eve", age: 32, city: "Berlin", active: false }
                    ];
                    this.jsonInput = JSON.stringify(this.originalData, null, 2);
                    
                    // Инициализация D3 визуализации
                    this.initPipelineVisualization();
                    
                    // Предупреждение при закрытии
                    window.addEventListener('beforeunload', (e) => {
                        if (this.pipelineSteps.length > 0) {
                            e.preventDefault();
                            e.returnValue = 'You have unsaved transformations. Are you sure you want to leave?';
                        }
                    });
                },

                // Загрузка пользовательских данных
                loadCustomData(jsonString) {
                    const validation = this.validateJSON(jsonString);
                    if (!validation.isValid) {
                        this.showNotification(validation.error, 'error');
                        return;
                    }
                    
                    this.originalData = validation.data;
                    this.pipelineSteps = [];
                    this.nextStepId = 1;
                    this.updatePipelineVisualization();
                    this.saveToHistory();
                    this.showNotification('Data loaded successfully!', 'success');
                },

                // Сброс к примеру данных
                resetToSample() {
                    this.jsonInput = JSON.stringify(this.originalData, null, 2);
                    this.loadCustomData(this.jsonInput);
                },

                // Обработка загрузки файла
                handleFileUpload(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    // Проверяем размер файла (макс 5MB)
                    if (file.size > 5 * 1024 * 1024) {
                        this.showNotification('File size must be less than 5MB', 'error');
                        event.target.value = '';
                        return;
                    }
                    
                    // Проверяем тип файла
                    if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
                        this.showNotification('Only JSON files are allowed', 'error');
                        event.target.value = '';
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            this.jsonInput = e.target.result;
                            this.loadCustomData(e.target.result);
                        } catch (error) {
                            this.showNotification('Error reading file: ' + error.message, 'error');
                        }
                        event.target.value = '';
                    };
                    reader.onerror = () => {
                        this.showNotification('Error reading file', 'error');
                        event.target.value = '';
                    };
                    reader.readAsText(file);
                },

                // Валидация JSON
                validateJSON(jsonString) {
                    try {
                        const parsed = JSON.parse(jsonString);
                        if (!Array.isArray(parsed)) {
                            return { isValid: false, error: 'Data must be a JSON array' };
                        }
                        // Ограничиваем размер данных
                        if (parsed.length > 10000) {
                            return { isValid: false, error: 'Maximum 10,000 items allowed' };
                        }
                        return { isValid: true, data: parsed };
                    } catch (error) {
                        return { isValid: false, error: 'Invalid JSON format' };
                    }
                },

                // Получение входных данных для шага
                getStepInput(index) {
                    if (index === 0) {
                        return this.originalData;
                    }
                    const prevResult = this.pipelineSteps[index - 1].result;
                    return Array.isArray(prevResult) ? prevResult : [];
                },

                // Добавление шага
                addStep() {
                    if (this.pipelineSteps.length >= 20) {
                        this.showNotification('Maximum 20 transformation steps allowed', 'error');
                        return;
                    }
                    
                    this.pipelineSteps.push({
                        id: this.nextStepId++,
                        method: 'map',
                        name: '',
                        parameters: this.getDefaultParameters('map'),
                        result: null,
                        error: null
                    });
                    this.saveToHistory();
                },

                // Изменение метода шага
                onMethodChange(index) {
                    this.pipelineSteps[index].parameters = this.getDefaultParameters(this.pipelineSteps[index].method);
                    this.pipelineSteps[index].result = null;
                    this.pipelineSteps[index].error = null;
                    this.saveToHistory();
                },

                // Удаление шага
                removeStep(index) {
                    this.pipelineSteps.splice(index, 1);
                    this.recalculatePipeline();
                    this.saveToHistory();
                },

                // Получение параметров по умолчанию для метода
                getDefaultParameters(method) {
                    const defaults = {
                        map: { sourceField: '', expression: 'item' },
                        filter: { condition: 'true' },
                        reduce: { initialValue: '0', reducerFunction: 'acc + item' },
                        flatMap: { expression: 'item' },
                        slice: { start: '0', end: '' },
                        concat: { arrayToConcat: '[]' },
                        join: { separator: ',', sourceField: '' }
                    };
                    return JSON.parse(JSON.stringify(defaults[method]));
                },

                // Проверка возможности выполнения шага
                isStepExecutable(index) {
                    const inputData = this.getStepInput(index);
                    return Array.isArray(inputData) && inputData.length > 0;
                },

                // Выполнение шага
                executeStep(index) {
                    try {
                        const step = this.pipelineSteps[index];
                        const inputData = this.getStepInput(index);
                        
                        // Валидация параметров
                        this.validateStepParameters(step);
                        
                        // Выполнение метода
                        let result;
                        switch (step.method) {
                            case 'map':
                                result = this.executeMap(inputData, step.parameters);
                                break;
                            case 'filter':
                                result = this.executeFilter(inputData, step.parameters);
                                break;
                            case 'reduce':
                                result = this.executeReduce(inputData, step.parameters);
                                break;
                            case 'flatMap':
                                result = this.executeFlatMap(inputData, step.parameters);
                                break;
                            case 'slice':
                                result = this.executeSlice(inputData, step.parameters);
                                break;
                            case 'concat':
                                result = this.executeConcat(inputData, step.parameters);
                                break;
                            case 'join':
                                result = this.executeJoin(inputData, step.parameters);
                                break;
                            default:
                                throw new Error(`Unknown method: ${step.method}`);
                        }

                        step.result = result;
                        step.error = null;
                        
                        // Пересчитываем последующие шаги
                        this.recalculateSubsequentSteps(index);
                        this.updatePipelineVisualization();
                        this.saveToHistory();
                        
                    } catch (error) {
                        this.pipelineSteps[index].error = error.message;
                        this.showNotification(`Error in step ${index + 1}: ${error.message}`, 'error');
                    }
                },

                // Валидация параметров шага
                validateStepParameters(step) {
                    const { method, parameters } = step;
                    
                    switch (method) {
                        case 'slice':
                            const start = parseInt(parameters.start);
                            if (isNaN(start) || start < 0) {
                                throw new Error('Start must be a positive number');
                            }
                            if (parameters.end && (parseInt(parameters.end) < start)) {
                                throw new Error('End must be greater than start');
                            }
                            break;
                            
                        case 'reduce':
                            try {
                                JSON.parse(parameters.initialValue);
                            } catch {
                                throw new Error('Initial value must be valid JSON');
                            }
                            break;
                            
                        case 'concat':
                            try {
                                const parsed = JSON.parse(parameters.arrayToConcat);
                                if (!Array.isArray(parsed)) {
                                    throw new Error('Must be a valid array');
                                }
                            } catch (error) {
                                throw new Error(`Invalid array format: ${error.message}`);
                            }
                            break;
                    }
                },

                // Безопасное выполнение выражения
                safeEval(expression, context) {
                    // Создаем безопасный контекст
                    const safeContext = {
                        Math: Math,
                        JSON: JSON,
                        Date: Date,
                        String: String,
                        Number: Number,
                        Boolean: Boolean,
                        Array: Array,
                        Object: Object,
                        ...context
                    };
                    
                    // Создаем функцию с ограниченным доступом
                    const func = new Function(...Object.keys(safeContext), 
                        `"use strict"; 
                        try {
                            return ${this.sanitizeExpression(expression)};
                        } catch(e) {
                            throw new Error('Expression error: ' + e.message);
                        }`);
                    
                    return func(...Object.values(safeContext));
                },

                // Санитизация выражения
                sanitizeExpression(expr) {
                    const dangerousPatterns = [
                        /eval\s*\(/gi,
                        /Function\s*\(/gi,
                        /setTimeout\s*\(/gi,
                        /setInterval\s*\(/gi,
                        /document\./gi,
                        /window\./gi,
                        /localStorage/gi,
                        /sessionStorage/gi,
                        /fetch\s*\(/gi,
                        /XMLHttpRequest/gi,
                        /import\s*/gi,
                        /require\s*\(/gi,
                        /process\./gi,
                        /__proto__/gi,
                        /constructor/gi,
                        /prototype/gi
                    ];
                    
                    for (const pattern of dangerousPatterns) {
                        if (pattern.test(expr)) {
                            throw new Error('Expression contains forbidden code');
                        }
                    }
                    
                    return expr;
                },

                // Методы выполнения трансформаций
                executeMap(data, params) {
                    const { sourceField, expression } = params;
                    return data.map(item => {
                        try {
                            const value = sourceField ? item[sourceField] : item;
                            return this.safeEval(expression, { item: value });
                        } catch (error) {
                            throw new Error(`Map error: ${error.message}`);
                        }
                    });
                },

                executeFilter(data, params) {
                    const { condition } = params;
                    return data.filter(item => {
                        try {
                            return this.safeEval(condition, { item });
                        } catch (error) {
                            throw new Error(`Filter error: ${error.message}`);
                        }
                    });
                },

                executeReduce(data, params) {
                    const { initialValue, reducerFunction } = params;
                    try {
                        const initial = JSON.parse(initialValue);
                        return data.reduce((acc, item) => {
                            try {
                                return this.safeEval(reducerFunction, { acc, item });
                            } catch (error) {
                                throw new Error(`Reducer error: ${error.message}`);
                            }
                        }, initial);
                    } catch (error) {
                        throw new Error(`Invalid initial value: ${error.message}`);
                    }
                },

                executeFlatMap(data, params) {
                    const { expression } = params;
                    return data.flatMap(item => {
                        try {
                            const result = this.safeEval(expression, { item });
                            return Array.isArray(result) ? result : [result];
                        } catch (error) {
                            throw new Error(`FlatMap error: ${error.message}`);
                        }
                    });
                },

                executeSlice(data, params) {
                    const { start, end } = params;
                    const startNum = parseInt(start) || 0;
                    const endNum = end ? parseInt(end) : undefined;
                    return data.slice(startNum, endNum);
                },

                executeConcat(data, params) {
                    const { arrayToConcat } = params;
                    try {
                        const arrayToAdd = JSON.parse(arrayToConcat);
                        if (!Array.isArray(arrayToAdd)) {
                            throw new Error('Must be a valid array');
                        }
                        return [...data, ...arrayToAdd];
                    } catch (error) {
                        throw new Error('Invalid array format: ' + error.message);
                    }
                },

                executeJoin(data, params) {
                    const { separator, sourceField } = params;
                    
                    if (sourceField) {
                        const values = data
                            .map(item => item[sourceField])
                            .filter(value => value !== undefined && value !== null);
                        return values.join(separator || ',');
                    } else {
                        return data.map(item => JSON.stringify(item)).join(separator || ',');
                    }
                },

                // Пересчет последующих шагов
                recalculateSubsequentSteps(fromIndex) {
                    for (let i = fromIndex + 1; i < this.pipelineSteps.length; i++) {
                        const step = this.pipelineSteps[i];
                        if (step.result !== null) {
                            this.executeStep(i);
                        }
                    }
                },

                // Полный пересчет пайплайна
                recalculatePipeline() {
                    let currentData = [...this.originalData];
                    
                    for (let i = 0; i < this.pipelineSteps.length; i++) {
                        const step = this.pipelineSteps[i];
                        try {
                            step.result = this.executeStepLogic(i, currentData);
                            step.error = null;
                            currentData = Array.isArray(step.result) ? [...step.result] : step.result;
                        } catch (error) {
                            step.result = null;
                            step.error = error.message;
                            break;
                        }
                    }
                    
                    this.updatePipelineVisualization();
                },

                executeStepLogic(index, inputData) {
                    const step = this.pipelineSteps[index];
                    this.validateStepParameters(step);
                    
                    switch (step.method) {
                        case 'map': return this.executeMap(inputData, step.parameters);
                        case 'filter': return this.executeFilter(inputData, step.parameters);
                        case 'reduce': return this.executeReduce(inputData, step.parameters);
                        case 'flatMap': return this.executeFlatMap(inputData, step.parameters);
                        case 'slice': return this.executeSlice(inputData, step.parameters);
                        case 'concat': return this.executeConcat(inputData, step.parameters);
                        case 'join': return this.executeJoin(inputData, step.parameters);
                        default: throw new Error(`Unknown method: ${step.method}`);
                    }
                },

                // Инициализация D3 визуализации
                initPipelineVisualization() {
                    this.updatePipelineVisualization();
                },

                // Обновление D3 визуализации
                updatePipelineVisualization() {
                    const container = document.getElementById('pipelineChart');
                    if (!container) return;
                    
                    const width = container.clientWidth;
                    const height = 120;
                    
                    // Очищаем предыдущую визуализацию
                    d3.select('#pipelineChart').selectAll('*').remove();
                    
                    const svg = d3.select('#pipelineChart')
                        .append('svg')
                        .attr('width', width)
                        .attr('height', height);
                    
                    // Создаем узлы для визуализации
                    const nodes = [];
                    
                    // Начальный узел (исходные данные)
                    nodes.push({
                        id: 'source',
                        name: 'Source Data',
                        type: 'source',
                        count: this.originalData.length,
                        result: this.originalData
                    });
                    
                    // Узлы для каждого шага
                    this.pipelineSteps.forEach((step, index) => {
                        nodes.push({
                            id: `step-${step.id}`,
                            name: step.name || `Step ${index + 1}: ${step.method}`,
                            type: 'step',
                            method: step.method,
                            result: step.result,
                            index: index
                        });
                    });
                    
                    // Рассчитываем общую ширину и центрируем
                    const nodeWidth = 120;
                    const nodeHeight = 60;
                    const horizontalSpacing = 40;
                    const totalWidth = nodes.length * (nodeWidth + horizontalSpacing) - horizontalSpacing;
                    const startX = Math.max(20, (width - totalWidth) / 2);
                    
                    let currentX = startX;
                    
                    // Добавляем маркер для стрелок
                    svg.append('defs').append('marker')
                        .attr('id', 'arrowhead')
                        .attr('viewBox', '0 -5 10 10')
                        .attr('refX', 8)
                        .attr('refY', 0)
                        .attr('markerWidth', 6)
                        .attr('markerHeight', 6)
                        .attr('orient', 'auto')
                        .append('path')
                        .attr('d', 'M0,-5L10,0L0,5')
                        .attr('fill', '#6c757d');
                    
                    // Рисуем соединения
                    for (let i = 0; i < nodes.length - 1; i++) {
                        const x1 = currentX + nodeWidth;
                        const x2 = currentX + nodeWidth + horizontalSpacing;
                        const y = height / 2;
                        
                        svg.append('line')
                            .attr('x1', x1)
                            .attr('y1', y)
                            .attr('x2', x2)
                            .attr('y2', y)
                            .attr('stroke', '#dee2e6')
                            .attr('stroke-width', 2)
                            .attr('marker-end', 'url(#arrowhead)');
                        
                        currentX += nodeWidth + horizontalSpacing;
                    }
                    
                    // Сбрасываем позицию для узлов
                    currentX = startX;
                    
                    // Рисуем узлы
                    nodes.forEach((node, index) => {
                        const y = height / 2;
                        
                        const group = svg.append('g')
                            .attr('transform', `translate(${currentX}, ${y})`)
                            .attr('class', 'node')
                            .style('cursor', node.type === 'step' ? 'pointer' : 'default')
                            .on('click', () => {
                                if (node.type === 'step') {
                                    const element = document.querySelector(`[x-data] .transformation-block:nth-child(${node.index + 1})`);
                                    if (element) {
                                        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    }
                                }
                            });
                        
                        // Цвет узла
                        const nodeColor = node.type === 'source' ? '#28a745' : 
                                         node.result === null ? '#6c757d' : '#007bff';
                        
                        // Прямоугольник узла
                        group.append('rect')
                            .attr('width', nodeWidth)
                            .attr('height', nodeHeight)
                            .attr('x', -nodeWidth / 2)
                            .attr('y', -nodeHeight / 2)
                            .attr('rx', 8)
                            .attr('fill', nodeColor)
                            .attr('stroke', '#fff')
                            .attr('stroke-width', 2);
                        
                        // Текст узла
                        group.append('text')
                            .attr('text-anchor', 'middle')
                            .attr('dy', -5)
                            .attr('fill', 'white')
                            .style('font-size', '12px')
                            .style('font-weight', 'bold')
                            .text(node.type === 'source' ? 'SOURCE' : node.method.toUpperCase());
                        
                        group.append('text')
                            .attr('text-anchor', 'middle')
                            .attr('dy', 10)
                            .attr('fill', 'white')
                            .style('font-size', '10px')
                            .text(node.name.length > 15 ? node.name.substring(0, 15) + '...' : node.name);
                        
                        // Информация о данных
                        let dataInfo;
                        if (node.type === 'source') {
                            dataInfo = `${node.count} items`;
                        } else {
                            if (node.result === null) {
                                dataInfo = 'not executed';
                            } else if (Array.isArray(node.result)) {
                                dataInfo = `${node.result.length} items`;
                            } else {
                                dataInfo = typeof node.result === 'string' 
                                    ? (node.result.length > 10 ? node.result.substring(0, 10) + '...' : node.result)
                                    : String(node.result);
                            }
                        }
                        
                        group.append('text')
                            .attr('text-anchor', 'middle')
                            .attr('dy', 25)
                            .attr('fill', 'white')
                            .style('font-size', '9px')
                            .style('font-style', 'italic')
                            .text(dataInfo);
                        
                        currentX += nodeWidth + horizontalSpacing;
                    });
                },

                // Сохранение в историю
                saveToHistory() {
                    const state = {
                        pipelineSteps: JSON.parse(JSON.stringify(this.pipelineSteps)),
                        originalData: JSON.parse(JSON.stringify(this.originalData))
                    };
                    
                    // Удаляем всё после текущего индекса
                    if (this.historyIndex < this.history.length - 1) {
                        this.history = this.history.slice(0, this.historyIndex + 1);
                    }
                    
                    this.history.push(state);
                    this.historyIndex = this.history.length - 1;
                    this.isSaved = true;
                },

                // Восстановление из истории
                restoreFromHistory() {
                    if (this.historyIndex >= 0 && this.historyIndex < this.history.length) {
                        const state = this.history[this.historyIndex];
                        this.pipelineSteps = JSON.parse(JSON.stringify(state.pipelineSteps));
                        this.originalData = JSON.parse(JSON.stringify(state.originalData));
                        this.recalculatePipeline();
                        this.updatePipelineVisualization();
                    }
                },

                // Экспорт данных
                exportData() {
                    const dataStr = JSON.stringify(this.currentData, null, 2);
                    const dataBlob = new Blob([dataStr], {type: 'application/json'});
                    const url = URL.createObjectURL(dataBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'transformed-data.json';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                },

                // Копирование в буфер обмена
                copyToClipboard() {
                    const dataStr = JSON.stringify(this.currentData, null, 2);
                    navigator.clipboard.writeText(dataStr).then(() => {
                        this.showNotification('Data copied to clipboard!', 'success');
                    }).catch(err => {
                        this.showNotification('Failed to copy data', 'error');
                    });
                },

                // Показать уведомление
                showNotification(message, type = 'info') {
                    const container = document.getElementById('notificationContainer');
                    
                    const notification = document.createElement('div');
                    notification.className = `alert alert-${type === 'error' ? 'danger' : type} alert-dismissible fade show`;
                    notification.innerHTML = `
                        ${message}
                        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                    `;
                    
                    container.appendChild(notification);
                    
                    // Автоматически скрываем через 3 секунды
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 3000);
                }
            };
        }
    </script>
</body>
</html>
